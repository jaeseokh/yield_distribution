---
title: "2_2.Data_analysis"
author: "Jaeseok Hwang"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
  word_document: defaulta
---


## Knitr option

```{r, cache = F, echo = F, results = "hide"}
#####

library(knitr)
knitr::opts_chunk$set(
  cache = FALSE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 9,
  fig.height = 6
)
```

## Load packages

```{r packages}
library(here)
library(data.table)
library(tidyverse)
library(dplyr)
library(grf)
library(fixest)
library(moments)
library(pracma)
library(ggplot2)
library(huxtable)
library(mgcv)  # For GAM
library(plm)
library(gamlss)
library(gamlss.dist)
library(purrr)
library(plotly)

```

## Load data

```{r load-data}
# combined OFPE data from IL (2016 - 2023)
dat_comb <- readRDS(here("Data", "Processed", "Analysis_ready", "df_il.rds"))


# Select variables for regressions
dat <- dat_comb %>% 
        data.table() %>%
   .[, .(yield, n, sand, clay, silt, water_storage, elev,
      slope, aspect, prcp_t, gdd_t, edd_t, ffy_id)] %>%
        na.omit()

# Normalize yield before calculating moments, as in Tack et al. (2012)
# Tack (2012) scales yield to [0, 1] range before computing raw moments for stability
# This avoids large magnitude third moments and ensures comparable entropy constraints

yield_min <- min(dat$yield, na.rm = TRUE)
yield_max <- max(dat$yield, na.rm = TRUE)
dat[, yield_scaled := (yield - yield_min) / (yield_max - yield_min)]

# Compute normalized raw moments
# These are used as the response variables in moment regressions (OLS and GAM)
dat[, yield_m1 := yield_scaled]
dat[, yield_m2 := yield_scaled^2]
dat[, yield_m3 := yield_scaled^3]



```



# -------------------------------
#  Define the objective
# -------------------------------
# Goal: Estimate the full conditional yield distribution
# for each combination of nitrogen rate and weather, 
# using multi-field trial data from 2016 to 2023 in Illinois in USA.
# This includes modeling the mean, variance, and skewness of yield
# while controlling for field-level fixed effects; ffy_id.

# 1. Estimate First, Second, Third Raw Moments

```{r moment estimation}

# By OLS
mod_m1 <- lm(yield_m1 ~ n + sand + clay + silt + water_storage +
                  elev + slope + aspect + prcp_t + gdd_t + edd_t , data = dat)

mod_m2 <- lm(yield_m2 ~ n + sand + clay + silt + water_storage +
                  elev + slope + aspect + prcp_t  + gdd_t + edd_t, data = dat)

mod_m3 <- lm(yield_m3 ~ n + sand + clay + silt + water_storage +
                  elev + slope + aspect + prcp_t + gdd_t + edd_t, data = dat)

# By GAM
gam_mu1 <- gam(yield_m1 ~ s(n, k = 5) + s(prcp_t, k = 5) + s(gdd_t, k = 5) +
  sand + clay + silt + water_storage + elev + slope + aspect + edd_t,
  data = dat, method = "REML")

gam_mu2 <- gam(I(yield_m2) ~ s(n, k = 5) + s(prcp_t, k = 5) + s(gdd_t, k = 5) +
  sand + clay + silt + water_storage + elev + slope + aspect + edd_t,
  data = dat, method = "REML")

gam_mu3 <- gam(I(yield_m3) ~ s(n, k = 5) + s(prcp_t, k = 5) + s(gdd_t, k = 5) +
  sand + clay + silt + water_storage + elev + slope + aspect + edd_t,
  data = dat, method = "REML")

```

# 2. Create Prediction Grid

```{r prediction}

# Median values for other covariates
cov_meds <- dat[, .(sand = median(sand), clay = median(clay), silt = median(silt),
             water_storage = median(water_storage), elev = median(elev),
            slope = median(slope), aspect = median(aspect),
              gdd_t = median(gdd_t),edd_t = median(edd_t))]

# Prediction grid
n_seq <- quantile(dat$n, probs = seq(0.1, 0.9, length.out = 5), na.rm = TRUE)
prcp_seq <- quantile(dat$prcp_t, probs = seq(0.1, 0.9, length.out = 5), na.rm = TRUE)

grid <- CJ(n = n_seq, prcp_t = prcp_seq)
grid <- cbind(grid, cov_meds[rep(1, nrow(grid))])

# Predict Raw Moments by OLS

grid[, mu1 := predict(mod_m1, newdata = grid)]
grid[, mu2 := predict(mod_m2, newdata = grid)]
grid[, mu3 := predict(mod_m3, newdata = grid)]

# Predict Raw moments by GAM
grid[, mu1_gam := predict(gam_mu1, newdata = grid)]
grid[, mu2_gam := predict(gam_mu2, newdata = grid)]
grid[, mu3_gam := predict(gam_mu3, newdata = grid)]


grid[, var_check := mu2 - mu1^2]
summary(grid$var_check)
grid[var_check <= 0]


```

## 3. Maximum Entropy Estimation Based on OLS and GAM Moments

```{r mbme-density-ols-vs-gam}

# Define MBME estimator function
estimate_mbme_density <- function(mu1, mu2, mu3, support = c(0, 1)) {
  if (any(is.na(c(mu1, mu2, mu3))) || (mu2 - mu1^2 <= 0)) {
    warning("Invalid or inconsistent moment inputs.")
    return(NULL)
  }

  safe_exp <- function(x) {
    x <- ifelse(x > 700, 700, x)  # avoid overflow in exp()
    exp(x)
  }

  # Objective: match estimated vs. target raw moments over [0, 1]
  f_obj <- function(lambda) {
    Z <- tryCatch(
      integrate(function(y) safe_exp(lambda[1]*y + lambda[2]*y^2 + lambda[3]*y^3), 0, 1)$value,
      error = function(e) Inf
    )
    m1 <- tryCatch(
      integrate(function(y) y * safe_exp(lambda[1]*y + lambda[2]*y^2 + lambda[3]*y^3), 0, 1)$value / Z,
      error = function(e) Inf
    )
    m2 <- tryCatch(
      integrate(function(y) y^2 * safe_exp(lambda[1]*y + lambda[2]*y^2 + lambda[3]*y^3), 0, 1)$value / Z,
      error = function(e) Inf
    )
    m3 <- tryCatch(
      integrate(function(y) y^3 * safe_exp(lambda[1]*y + lambda[2]*y^2 + lambda[3]*y^3), 0, 1)$value / Z,
      error = function(e) Inf
    )
    sum((c(m1, m2, m3) - c(mu1, mu2, mu3))^2)
  }

  # First try with BFGS, then fallback to box-constrained L-BFGS-B if needed
  res <- tryCatch({
    optim(par = c(0, 0, 0), fn = f_obj, method = "BFGS")
  }, error = function(e) NULL)

  if (is.null(res) || res$convergence != 0) {
    res <- tryCatch({
      optim(par = c(0, 0, 0), fn = f_obj, method = "L-BFGS-B",
            lower = rep(-50, 3), upper = rep(50, 3))
    }, error = function(e) NULL)
  }

  if (is.null(res) || res$convergence != 0) {
    warning("MBME optimization failed â€” returning NULL.")
    return(NULL)
  }

  lambda <- res$par

  # Return MBME density function on [support]
  function(y) {
    y_s <- (y - support[1]) / (support[2] - support[1])
    Z <- integrate(function(x) safe_exp(lambda[1]*x + lambda[2]*x^2 + lambda[3]*x^3), 0, 1)$value
    safe_exp(lambda[1]*y_s + lambda[2]*y_s^2 + lambda[3]*y_s^3) / (Z * (support[2] - support[1]))
  }
}

# Common yield grid (rescaled to [0, 1] to match normalized moments)
yield_grid <- seq(0, 1, length.out = 101)

# --- MBME Results from OLS moments ---
mbme_list_ols <- list()

# Add regularization to prevent invalid moment combinations
grid[, mu2 := pmax(mu2, mu1^2 + 1e-4)]  # Ensures positive-definite second moment
grid[, mu3 := pmin(pmax(mu3, mu2 * mu1 + 1e-4), mu1)]  # Trim skewness for feasibility

for (i in seq_len(nrow(grid))) {
  mu1 <- grid$mu1[i]
  mu2 <- grid$mu2[i]
  mu3 <- grid$mu3[i]

  f_density <- tryCatch(
    estimate_mbme_density(mu1, mu2, mu3, support = c(0, 1)),
    error = function(e) {
      message("Failed at row ", i, ": ", conditionMessage(e))
      return(NULL)
    }
  )

  if (!is.null(f_density)) {
    dens_vals <- sapply(yield_grid, f_density)
    mbme_list_ols[[i]] <- data.table(
      grid_row = i,
      yield = yield_grid * (yield_max - yield_min) + yield_min,  # Back-transform
      density = dens_vals / (yield_max - yield_min),  # Adjust for scale
      n = grid$n[i],
      prcp_t = grid$prcp_t[i],
      method = "OLS"
    )
  }
}

# --- MBME Results from GAM moments ---
mbme_list_gam <- list()

grid[, mu2_gam := pmax(mu2_gam, mu1_gam^2 + 1e-4)]
grid[, mu3_gam := pmin(pmax(mu3_gam, mu2_gam * mu1_gam + 1e-4), mu1_gam)]

for (i in seq_len(nrow(grid))) {
  mu1 <- grid$mu1_gam[i]
  mu2 <- grid$mu2_gam[i]
  mu3 <- grid$mu3_gam[i]

  f_density <- tryCatch(
    estimate_mbme_density(mu1, mu2, mu3, support = c(0, 1)),
    error = function(e) {
      message("Failed at row ", i, ": ", conditionMessage(e))
      return(NULL)
    }
  )

  if (!is.null(f_density)) {
    dens_vals <- sapply(yield_grid, f_density)
    mbme_list_gam[[i]] <- data.table(
      grid_row = i,
      yield = yield_grid * (yield_max - yield_min) + yield_min,
      density = dens_vals / (yield_max - yield_min),
      n = grid$n[i],
      prcp_t = grid$prcp_t[i],
      method = "GAM"
    )
  }
}

# Combine and label
mbme_results_ols <- rbindlist(mbme_list_ols, use.names = TRUE)
mbme_results_gam <- rbindlist(mbme_list_gam, use.names = TRUE)
mbme_results_all <- rbindlist(list(mbme_results_ols, mbme_results_gam), use.names = TRUE)

# Label for plotting (revised to use only prcp_t as weather factor)
mbme_results_all[, weather := paste0("prcp = ", round(prcp_t, 1))]
weather_levels <- mbme_results_all[, sort(unique(weather))]
mbme_results_all[, weather := factor(weather, levels = weather_levels)]
mbme_results_all[, n_round := factor(round(n, 0), levels = sort(unique(round(n, 0))))]

```




## 4. Plot distribution of Yield-N x weather

```{r mbme-density-ols-vs-gam}

# Use OLS MBME results and label by prcp_t
mbme_3d <- mbme_results_ols

# Create a concise weather label using only prcp_t
mbme_3d[, weather_label := paste0("prcp = ", round(prcp_t, 1))]

# Ensure weather_label is treated as a factor with sorted levels
mbme_3d[, weather_label := factor(weather_label, levels = sort(unique(weather_label)))]

# Choose a specific precipitation level (e.g., closest to 60)
prcp_target <- 60
subset_data <- mbme_results_all[prcp_t == 645.5]

# Create concise method label
subset_data[, method := factor(method, levels = c("OLS", "GAM"))]

# Create 3D plot comparing GAM vs OLS for a single prcp scenario
p <- plot_ly()

for (m in levels(subset_data$method)) {
  df <- subset_data[method == m][order(n, yield)]

  p <- add_trace(
    p,
    x = df$n,
    y = df$yield,
    z = df$density,
    type = "scatter3d",
    mode = "lines",
    name = paste0(m, " (prcp = ", round(prcp_target, 1), ")"),
    line = list(width = 4)
  )
}

p <- layout(p,
  scene = list(
    xaxis = list(title = "Nitrogen (lbs/ac)"),
    yaxis = list(title = "Yield (bu/ac)"),
    zaxis = list(title = "Density"),
    camera = list(eye = list(x = 1.3, y = 1.3, z = 0.7))
  ),
  title = paste("Yieldâ€“Nitrogen MBME Curves at prcp =", prcp_target)
)

p

```